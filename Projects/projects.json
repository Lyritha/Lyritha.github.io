[
  {
    "title": "The Filth",
    "subtitle": "90's desktop bullet hell.",
    "thumbnail": "Projects/TheFilth/TheFilth_preview.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "The Filth is a space shooter-like game made during a gamejam with the theme: \"Making free space\", where you have to shoot at files to destroy them, and survive their attacks. \n\nAs the player you can shoot projectiles to destroy enemies, and also have access to a special attack that hurts multiple enemies.",
        "section-image": "Projects/TheFilth/TheFilth_preview.png"
      },
      {
        "?section-name": "contribution",
        "?section-icon": "Images/Icons/briefcase.png",
        "section-description": "In this project my role was SCRUM master and lead developer. \n\nI focused on integrating game systems that the other group members made, but also made my own systems like the spawning grid. I also made the UI of the game.",
        "section-image": "Projects/TheFilth/TheFilth_preview2.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/TheFilth/TheFilth_preview.png",
          "Projects/TheFilth/TheFilth_sprites.png",
          "Projects/TheFilth/TheFilth_preview2.png"
        ]
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "csharp",
        "section-code": "\/\/\/ Controls the \"eye\" in the center of the screen. \r\n\/\/\/ it either looks at the player or a random points on screen, \r\n\/\/\/ switching targets at random intervals.\r\n\r\nusing System.Collections;\r\nusing UnityEngine;\r\n\r\npublic class TheFilthLook : MonoBehaviour\r\n{\r\n    [SerializeField] \r\n    private GameObject eye = null;\r\n    [SerializeField]\r\n    private float minDistanceFromPlayer = 0.5f;\r\n    [SerializeField]\r\n    private Vector2 TargetSwitchDelay = Vector2.zero;\r\n    [SerializeField]\r\n    private float lookSpeed = 5f;\r\n\r\n    private Transform playerT = null;\r\n    private float minX, maxX, minY, maxY = 0;\r\n    private bool isFollowingPlayer = false;\r\n    private Vector2 target = Vector2.zero;\r\n\r\n    void Start()\r\n    {\r\n        playerT = GameObject.FindGameObjectWithTag(\"Player\").transform;\r\n\r\n        \/\/ensures the eye chooses a point that's actually on the screen.\r\n        Vector2 bottomLeft = Camera.main.ViewportToWorldPoint(Vector2.zero);\r\n        Vector2 topRight = Camera.main.ViewportToWorldPoint(Vector2.one);\r\n\r\n        minX = bottomLeft.x;\r\n        minY = bottomLeft.y;\r\n        maxX = topRight.x;\r\n        maxY = topRight.y;\r\n\r\n        target = transform.position;\r\n        StartCoroutine(ChooseTarget());\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        \/\/\/ calculates the point where the eye needs to move to, \r\n        \/\/\/ limited to a radius from the root object.\r\n        Vector2 dir = target - (Vector2)transform.position;\r\n        float distance = dir.magnitude;\r\n\r\n        if (distance > 0f)\r\n        {\r\n            dir \/= distance;\r\n        }\r\n\r\n        dir *= minDistanceFromPlayer;\r\n\r\n        if (isFollowingPlayer && distance > minDistanceFromPlayer)\r\n        {\r\n            target = playerT.position;\r\n        }\r\n\r\n        \/\/ actually move the eye, smoothly\r\n        eye.transform.position = Vector2.Lerp\r\n            (\r\n                eye.transform.position,\r\n                (Vector2)transform.position + dir,\r\n                Time.deltaTime * lookSpeed\r\n            );\r\n    }\r\n\r\n    IEnumerator ChooseTarget()\r\n    {\r\n        \/\/ delay to avoid it moving at the start.\r\n        yield return new WaitForSecondsRealtime(10f);\r\n\r\n        \/\/ not save, but okay for a gamejam game.\r\n        while (true)\r\n        {\r\n            float minDelay = TargetSwitchDelay.x;\r\n            float maxDelay = TargetSwitchDelay.y;\r\n\r\n            if (isFollowingPlayer)\r\n            {\r\n                minDelay += 5;\r\n                maxDelay += 5;\r\n            }\r\n\r\n            float randomDelay = Random.Range(minDelay, maxDelay);\r\n            yield return new WaitForSecondsRealtime(randomDelay);\r\n\r\n            isFollowingPlayer = Random.value < 0.5f;\r\n\r\n            if (!isFollowingPlayer)\r\n            {\r\n                target = ChooseRandomLookTarget();\r\n            }\r\n        }\r\n    }\r\n\r\n    Vector2 ChooseRandomLookTarget()\r\n    {\r\n        Vector2 target = Vector2.zero;\r\n\r\n        target.x = Random.Range(minX, maxX);\r\n        target.y = Random.Range(minY, maxY);\r\n\r\n        return target;\r\n    }\r\n}\r\n"
      }
    ],
    "links": [
      {
        "name": "Github",
        "icon": "Images/Logos/Github.png",
        "link": "https://github.com/Lyritha/TheFilth/releases/tag/GameJam-Release"
      },
      {
        "name": "UnityPlay",
        "icon": "Images/Logos/unity.png",
        "link": "https://play.unity.com/en/games/b90b0494-ef42-4095-bdf8-ac9bbe0ff9be/the-filth"
      }
    ]
  },
  {
    "title": "Cyberpunk gun",
    "subtitle": "model made for fun",
    "thumbnail": "Projects/gun/weapon.png",
    "data-filter": "Blender",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "I made this model as a side project for myself, I slowly worked on it over the course of around 2 months i spend a bit of time on it every so often.\n\nI used no reference images to make this model as a challenge for myself.",
        "section-image": "Projects/gun/weapon.png"
      },
      {
        "?section-name": "3D model",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-scene": {
          "path": "Projects/gun/Gun.glb",
          "hdrPathOrHex": "Images/skyboxes/night_sky.hdr",
          "cameraPosition": [ -1.98, 2.29, 5.07 ],
          "cameraRotation": [ -0.27, -0.25, -0.07 ],
          "cameraTarget": [ -0.58, 0.82, -0.26 ],
          "cameraZoom": {
            "min": 0.1,
            "max": 10,
            "current": 7
          }
        }
      }
    ]
  },
  {
    "title": "Towaria",
    "subtitle": "A voxel based tower defense.",
    "thumbnail": "Projects/Towaria/towaria_preview.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "Towaria is a challenging tower defense game where letting enemies reach the end means defeat. \n\nPlace auto-firing towers to eliminate all enemies and advance through waves. Survive the final wave to move on to the next level.",
        "section-image": "Projects/Towaria/towaria_preview.png"
      },
      {
        "?section-name": "contribution",
        "?section-icon": "Images/Icons/briefcase.png",
        "section-description": "I focused on core game mechanics, like tower placement and stats. \n\nI also contributed to 3D models (ground tiles, a tower, enemies) and helped polish the UI to ensure visual consistency after functionality was implemented.",
        "section-image": "Projects/Towaria/towaria_preview2.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/Towaria/towaria_preview.png",
          "Projects/Towaria/towaria_preview2.png",
          "Projects/Towaria/towaria_3d_models.png"
        ]
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "csharp",
        "section-code": "\/\/\/ This script manages the movement of every enemy.  \r\n\/\/\/ Add an enemy to the list if you want it to be controlled by this script,  \r\n\/\/\/ remove it when you want it to stop being controlled by this script.\r\n\r\nusing UnityEngine;\r\nusing Unity.Jobs;\r\nusing Unity.Burst;\r\nusing Unity.Collections;\r\nusing UnityEngine.Jobs;\r\nusing System.Collections.Generic;\r\n\r\npublic class EnemyMovementSystem : MonoBehaviour\r\n{\r\n    \/\/ Enemies hold all enemies. enemiesToUpdate is a list of all enemies used in the current job,\r\n    \/\/ to avoid shifting list issues.\r\n    private readonly List<EnemyBase> enemies = new();\r\n    private List<EnemyBase> enemiesToUpdate = new();\r\n\r\n    \/\/ Store some values to avoid having to call pathCreator more than needed.\r\n    public Vector3 PathStart { get; private set; }\r\n    private int pathReachedEndIndex;\r\n\r\n    \/\/ Data to pass on to job. Native arrays are required when using jobs (multithreading).\r\n    private TransformAccessArray enemyTransforms;\r\n    private NativeArray<Vector3> pathNodes;\r\n    private NativeArray<float> speeds;\r\n    private NativeArray<Vector3> offsets;\r\n    private NativeArray<int> targetNodeIndices;\r\n    private CreateAIPath pathCreator;\r\n    \/\/ Stores a reference to the job itself.\r\n    private JobHandle jobHandle;\r\n    private bool jobAlreadyCompleted = false;\r\n\r\n    \/\/ Allow enemy to add and remove itself to the movement job.\r\n    public void AddEnemy(EnemyBase enemy) => enemies.Add(enemy);\r\n    public void RemoveEnemy(EnemyBase enemy) => enemies.Remove(enemy);\r\n\r\n    private void Start()\r\n    {\r\n        pathCreator = FindFirstObjectByType<CreateAIPath>();\r\n        pathCreator.RegeneratedPaths += InitializePathNodes;\r\n    }\r\n\r\n    public void InitializePathNodes()\r\n    {\r\n        PathStart = pathCreator.Path[0];\r\n        pathReachedEndIndex = pathCreator.Path.Count;\r\n\r\n        \/\/ Dispose the pathNodes if it has already been created.\r\n        if (pathNodes.IsCreated)\r\n        {\r\n            jobHandle.Complete();\r\n            pathNodes.Dispose();\r\n        }\r\n\r\n        pathNodes = new NativeArray<Vector3>(pathCreator.Path.ToArray(), Allocator.Persistent);\r\n    }\r\n\r\n    \/\/ Called after update functions have been called.\r\n    private void Update()\r\n    {\r\n        \/\/ If the job is completed, complete the job,\r\n        \/\/ write some data to the AI and create a new job.\r\n        if (jobHandle.IsCompleted)\r\n        {\r\n            \/\/ Force job to complete.\r\n            jobHandle.Complete();\r\n\r\n            \/\/ If this is the first time this job has been marked as completed, run this code,\r\n            \/\/ to avoid unnecessary repeated writing to the enemies.\r\n            if (!jobAlreadyCompleted)\r\n            {\r\n                \/\/ Mark this job as already completed once.\r\n                jobAlreadyCompleted = true;\r\n\r\n                \/\/ Check if the enemy count is greater than 0,\r\n                \/\/ and if all the arrays are created (by checking the main one).\r\n                if (enemiesToUpdate.Count > 0 && enemyTransforms.isCreated)\r\n                {\r\n                    \/\/ Update target indices of the enemies using information from the job.\r\n                    for (int i = 0; i < enemiesToUpdate.Count; i++)\r\n                    {\r\n                        enemiesToUpdate[i].TargetNodeIndex = targetNodeIndices[i];\r\n                        if (enemiesToUpdate[i].TargetNodeIndex >= pathReachedEndIndex)\r\n                        {\r\n                            enemiesToUpdate[i].HasReachedEnd();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \/\/ Dispose of the data that changes between jobs to free up space.\r\n                DisposeMost();\r\n            }\r\n\r\n            \/\/ Create and run a new job only if there are enemies present.\r\n            if (enemies.Count > 0)\r\n            {\r\n                jobAlreadyCompleted = false;\r\n                jobHandle = CreateJobData().Schedule(enemyTransforms);\r\n            }\r\n        }\r\n    }\r\n\r\n    public EnemyMoveJob CreateJobData()\r\n    {\r\n        enemiesToUpdate = new(enemies);\r\n\r\n        \/\/ Create new native arrays with the length of enemies.\r\n        enemyTransforms = new TransformAccessArray(enemiesToUpdate.Count);\r\n        speeds = new NativeArray<float>(enemiesToUpdate.Count, Allocator.Persistent);\r\n        offsets = new NativeArray<Vector3>(enemiesToUpdate.Count, Allocator.Persistent);\r\n        targetNodeIndices = new NativeArray<int>(enemiesToUpdate.Count, Allocator.Persistent);\r\n\r\n        \/\/ Fill all the native arrays in a single for loop,\r\n        \/\/ skip hasReachedEnd because we fill it with false for every enemy.\r\n        for (int i = 0; i < enemiesToUpdate.Count; i++)\r\n        {\r\n            EnemyBase enemy = enemiesToUpdate[i];\r\n            enemyTransforms.Add(enemy.transform);\r\n            speeds[i] = enemy.Speed;\r\n            offsets[i] = enemy.RandomOffset;\r\n            targetNodeIndices[i] = enemy.TargetNodeIndex;\r\n        }\r\n\r\n        \/\/ Return the data as an EnemyMoveJob struct,\r\n        \/\/ this needs to be filled in fully, otherwise the job gets angry.\r\n        return new()\r\n        {\r\n            DeltaTime = Time.deltaTime,\r\n            PathNodes = pathNodes,\r\n            Speeds = speeds,\r\n            Offsets = offsets,\r\n            TargetNodeIndices = targetNodeIndices,\r\n        };\r\n    }\r\n\r\n    \/\/ Dispose of everything when this object is destroyed,\r\n    \/\/ otherwise unnecessary memory is used.\r\n    private void OnDestroy()\r\n    {\r\n        jobHandle.Complete();\r\n        DisposeMost();\r\n        if (pathNodes.IsCreated) pathNodes.Dispose();\r\n    }\r\n\r\n    \/\/\/ <summary>\r\n    \/\/\/ Dispose of data that changes between jobs to free up space.\r\n    \/\/\/ Garbage collection doesn't happen automatically on native arrays;\r\n    \/\/\/ you have to dispose of them yourself, otherwise you will get a memory leak.\r\n    \/\/\/ <\/summary>\r\n    private void DisposeMost()\r\n    {\r\n        if (enemyTransforms.isCreated) enemyTransforms.Dispose();\r\n        if (speeds.IsCreated) speeds.Dispose();\r\n        if (offsets.IsCreated) offsets.Dispose();\r\n        if (targetNodeIndices.IsCreated) targetNodeIndices.Dispose();\r\n    }\r\n}\r\n\r\n\/\/ Burst compiler, very efficient, but limited Unity functions.\r\n\/\/ Also garbage collection needs to be done by yourself.\r\n[BurstCompile]\r\npublic struct EnemyMoveJob : IJobParallelForTransform\r\n{\r\n    \/\/ Data as a struct. When you don't want a job to modify data,\r\n    \/\/ make sure it's set to readonly.\r\n    [ReadOnly] public float DeltaTime;\r\n    [ReadOnly] public NativeArray<Vector3> PathNodes;\r\n    [ReadOnly] public NativeArray<float> Speeds;\r\n    [ReadOnly] public NativeArray<Vector3> Offsets;\r\n    public NativeArray<int> TargetNodeIndices;\r\n\r\n    \/\/ Move every object with its own data.\r\n    public void Execute(int index, TransformAccess transform)\r\n    {\r\n        \/\/ If target index is too big, just don't.\r\n        if (TargetNodeIndices[index] >= PathNodes.Length)\r\n        {\r\n            Debug.LogWarning($\"Target index of enemy {index} was out of range of the path.\");\r\n            return;\r\n        }\r\n\r\n        \/\/ Get the information for this specific index.\r\n        float speed = Speeds[index];\r\n        Vector3 offset = Offsets[index];\r\n        int targetNodeIndex = TargetNodeIndices[index];\r\n\r\n        \/\/ If target index is 0 (at the start of the path),\r\n        \/\/ position at the beginning and increment the target position.\r\n        if (targetNodeIndex == 0)\r\n        {\r\n            transform.SetPositionAndRotation(PathNodes[targetNodeIndex], Quaternion.identity);\r\n            targetNodeIndex++;\r\n            TargetNodeIndices[index] = targetNodeIndex;\r\n        }\r\n\r\n        \/\/ Save the current and target position.\r\n        Vector3 currentPosition = transform.position;\r\n        Vector3 targetPosition = PathNodes[targetNodeIndex] + offset;\r\n\r\n        \/\/ Update the transform based on the distance you need to go.\r\n        transform.position = Vector3.MoveTowards(currentPosition, targetPosition, speed * DeltaTime);\r\n\r\n        \/\/ Check if needs to be rotated, if so rotate.\r\n        Vector3 direction = (targetPosition - currentPosition).normalized;\r\n        \/\/ If there's a valid direction, rotate smoothly.\r\n        if (direction.sqrMagnitude > 0.0001f) \/\/ Avoid division by zero and insignificant values.\r\n        {\r\n            \/\/ Get the target rotation based on the direction.\r\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\r\n            \/\/ Smoothly rotate from current rotation to target rotation.\r\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 5 * DeltaTime);\r\n        }\r\n\r\n        \/\/ Check if enemy has reached the target node with a tolerance.\r\n        if (Vector3.Distance(transform.position, targetPosition) <= 0.01f) TargetNodeIndices[index]++;\r\n    }\r\n}\r\n"
      }
    ],
    "links": [
      {
        "name": "Github",
        "icon": "Images/Logos/Github.png",
        "link": "https://github.com/Egg321123/J2P1_microgame/releases/tag/prototype-03"
      },
      {
        "name": "Direct",
        "icon": "Images/Icons/download.png",
        "link": "https://github.com/Egg321123/J2P1_microgame/releases/download/prototype-03/Towaria.apk"
      }
    ]
  },
  {
    "title": "SDF shader",
    "subtitle": "Shader made using glsl",
    "thumbnail": "Projects/Shaders/Fractel.png",
    "data-filter": "Shaders",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "This is the second project i made for my self-study task for my study, using various youtube video's to slowly learn GLSL. \n\nThe original shader was made to work within Shadertoy but had to be slightly modified to work on this website.",
        "section-image": "Projects/Shaders/Fractel.png"
      },
      {
        "?section-name": "Shader",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-shader-shadertoy": "precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(1.088, 0.928, 0.928);\n    vec3 b = vec3(0.478, 0.848, 0.638);\n    vec3 c = vec3(0.903, 0.668, 0.608);\n    vec3 d = vec3(1.067, 0.797, 0.528);\n\n    return a + b * cos(6.283185 * (c * t + d));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for(int i = 0; i < 3; i++) {\n        float fi = float(i);\n        vec3 col = vec3(0.0);\n\n        if(mod(fi, 2.0) == 0.0) col = palette(length(uv0) + fi * 0.4 + u_time / 2.0);\n        else col = palette(length(uv0) + fi * 0.4 - u_time / 2.0);\n\n        uv = fract(uv * 1.7) - 0.5;\n        float dist = length(uv);\n        float frequency = 10.0;\n\n        if(mod(fi, 2.0) == 0.0) dist = sin(dist * frequency + u_time) / frequency;\n        else dist = sin(dist * frequency - u_time) / frequency;\n\n        dist = abs(dist);\n        dist = 0.005 / dist;\n\n        finalColor += col * dist;\n    }\n\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "glsl",
        "section-code": "// cosine based palette, 4 vec3 params\nvec3 palette(float t) {\n    vec3 a = vec3(1.088, 0.928, 0.928);\n    vec3 b = vec3(0.478, 0.848, 0.638);\n    vec3 c = vec3(0.903, 0.668, 0.608);\n    vec3 d = vec3(1.067, 0.797, 0.528);\n    return a + b*cos(6.283185*(c*t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for(float i = 0.0; i < 3.0; i++) {\n        vec3 col = vec3(0.0);\n        if(mod(i, 2.0) == 0.0) col = palette(length(uv0) + i*0.4 + iTime/2.0);\n        else col = palette(length(uv0) + i*0.4 - iTime/2.0);\n\n        uv = fract(uv * 1.7) - 0.5;\n        float dist = length(uv);\n        float frequency = 10.0;\n\n        if(mod(i, 2.0) == 0.0) dist = sin(dist * frequency + iTime) / frequency;\n        else dist = sin(dist * frequency - iTime) / frequency;\n\n        dist = abs(dist);\n        dist = 0.005 / dist;\n\n        finalColor += col * dist;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}"
      }
    ]
  },
  {
    "title": "Tiny house",
    "subtitle": "A small cozy house",
    "thumbnail": "Projects/TinyHouse/Hous_Front.png",
    "data-filter": "Blender",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "A to-scale tiny house created in Blender. Everything in the scene was modeled by me, except for the grass. \n\nThis 3D model was made for a school assignment for my software development degree.",
        "section-image": "Projects/TinyHouse/Hous_Top.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/TinyHouse/Hous_Front.png",
          "Projects/TinyHouse/Hous_Top.png",
          "Projects/TinyHouse/Hous_Back.png",
          "Projects/TinyHouse/Hous_BedRoom.png",
          "Projects/TinyHouse/Hous_Bathroom.png"
        ]
      },
      {
        "?section-name": "3D model",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-scene": {
          "path": "Projects/TinyHouse/House.glb",
          "boundsName": "House",
          "hdrPathOrHex": "Images/skyboxes/day_sky.hdr",
          "cameraPosition": [ -3.39, 2.52, 3.52 ],
          "cameraRotation": [ -0.4, -0.74, -0.28 ],
          "cameraTarget": [ -0.01, 0.52, 0.01 ],
          "cameraZoom": {
            "min": 0.1,
            "max": 6.5,
            "current": 5.2
          }
        }
      }
    ]
  },
  {
    "title": "Ray Marching",
    "subtitle": "Shader made using glsl",
    "thumbnail": "Projects/Shaders/RayMarching.png",
    "data-filter": "Shaders",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "The third project i made for my self-study task for my study, as i've always loved raymarched geometry i wanted to try and make it myself. \n\nI made a lot of changes to the shader to work with Three.js, in addition i improved some performance issues and just did general polish.",
        "section-image": "Projects/Shaders/RayMarching.png"
      },
      {
        "?section-name": "Shader",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-shader-shadertoy": "precision highp float;\r\n\r\n\/\/ variables passed from the scene manager\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\nuniform vec3 u_camPos;\r\nuniform vec3 u_camRot;\r\nuniform float u_camNear;\r\nuniform float u_camFar;\r\nuniform float u_scrollModifier;\r\n\r\n\/\/ basic structure to save data about an object\r\nstruct Transform {\r\n    vec3 position;\r\n    vec3 rotation;\r\n    vec3 scale;\r\n};\r\n\r\nTransform defaultTransform() {\r\n    Transform t;\r\n    t.position = vec3(0.0);\r\n    t.rotation = vec3(0.0);\r\n    t.scale = vec3(1.0);\r\n    return t;\r\n}\r\n\r\n\/\/ logic handling object rotation\r\nvec3 rotateX(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\r\n}\r\n\r\nvec3 rotateZ(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\r\n}\r\n\r\nvec3 rot3D(vec3 p, vec3 rot) {\r\n    p = rotateX(p, rot.x);\r\n    p = rotateY(p, rot.y);\r\n    p = rotateZ(p, rot.z);\r\n    return p;\r\n}\r\n\r\nvec3 applyTransform(vec3 pos, Transform t) {\r\n    pos -= t.position;\r\n    pos = rot3D(pos, t.rotation);\r\n    pos \/= t.scale;\r\n    return pos;\r\n}\r\n\r\n\/\/ SDF's for specific shapes\r\nfloat sdSphere(vec3 p, float s) {\r\n    return length(p) - s;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\n\/\/ operators to combine 2 objects\r\nfloat opSmoothUnion(float d1, float d2, float k) {\r\n    float h = clamp(0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0);\r\n    return mix(d2, d1, h) - k*h*(1.0-h);\r\n}\r\n\r\n\/\/ color pallete\r\nvec3 palette(float t) {\r\n    vec3 a = vec3(0.681, 0.768, 0.968);\r\n    vec3 b = vec3(0.245, 0.764, 0.721);\r\n    vec3 c = vec3(1.202, 0.362, 0.660);\r\n    vec3 d = vec3(0.481, 3.592, 5.705);\r\n    return a + b*cos(6.283185*(c*t + d));\r\n}\r\n\r\n\r\n\/\/ returns the local position inside the cell (centered around 0)\r\n\/\/ and outputs the integer cell ID\r\nvec3 fractCell(vec3 worldPos, float cellSize, out vec3 cellId) {\r\n    vec3 scaledPos = worldPos \/ cellSize;\r\n    cellId = floor(scaledPos);\r\n    return fract(scaledPos) * cellSize - cellSize * 0.5;\r\n}\r\n\r\n\r\n\/\/ Helper to get a random value based on a position\r\nfloat randomValue(vec3 cellId) {\r\n    cellId = fract(cellId * 0.3183099 + 0.1);\r\n    cellId *= 17.0;\r\n    return fract(cellId.x * cellId.y * cellId.z * (cellId.x + cellId.y + cellId.z));\r\n}\r\n\r\n\/\/ create the object that is repeated across the scene\r\nfloat cubeSphere(vec3 worldPos) {\r\n    Transform boxTransform = defaultTransform();\r\n    vec3 cellId;\r\n    float cellSize = 2.0 * u_scrollModifier;\r\n\r\n    \/\/ get repeated local position and cell id\r\n    vec3 repeatedPos = fractCell(worldPos + vec3(0.0, 0.0, u_time), cellSize, cellId);\r\n\r\n    \/\/ random size per cell\r\n    float randSize = randomValue(cellId);\r\n    float size = 0.4 + randSize * 0.1;\r\n\r\n    \/\/ random rotation per cell\r\n    boxTransform.rotation = vec3(\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0\r\n    );\r\n\r\n    vec3 localPos = applyTransform(repeatedPos, boxTransform);\r\n    float box = sdBox(localPos, vec3(size));\r\n    float sphere = sdSphere(localPos, size);\r\n\r\n    \/\/ smooth saw tooth sine\r\n    float sine = sin(u_time * 6.283185 \/ 8.0);\r\n    float y = tanh(sine * 5.0) * 0.5 + 0.5;\r\n    \r\n    return mix(box, sphere, y);\r\n}\r\n\r\n\/\/ holds the entire scene to do raymarching on\r\nfloat scene(vec3 worldPos) {\r\n    Transform sphereTransform = defaultTransform();\r\n    float sphere = sdSphere(applyTransform(worldPos, sphereTransform), 1.0);\r\n\r\n    float cubeSphere = cubeSphere(worldPos); \r\n\r\n    return opSmoothUnion(sphere, cubeSphere, 0.4);\r\n}\r\n\r\n\/\/ Estimate gradient (normal) of the SDF at a point within the scene\r\nvec3 estimateNormal(vec3 p) {\r\n    float eps = 0.001;\r\n    float dx = scene(p + vec3(eps, 0.0, 0.0)) - scene(p - vec3(eps, 0.0, 0.0));\r\n    float dy = scene(p + vec3(0.0, eps, 0.0)) - scene(p - vec3(0.0, eps, 0.0));\r\n    float dz = scene(p + vec3(0.0, 0.0, eps)) - scene(p - vec3(0.0, 0.0, eps));\r\n    return normalize(vec3(dx, dy, dz));\r\n}\r\n\r\n\/\/ handles the shading of the scene, in a toony style\r\nvec3 shadeScene(vec3 sceneColor, vec3 hitPos, vec3 rayDir, float rayDistance) {\r\n    vec3 normal = vec3(0.0);\r\n    vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\r\n    float lighting = 1.0;\r\n\r\n    bool hit = (rayDistance < u_camFar);\r\n    if(hit) {\r\n        normal = estimateNormal(hitPos);\r\n\r\n        \/\/ Lambertian shading\r\n        float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\r\n\r\n        int steps = 3;\r\n        diffuse = floor(diffuse * float(steps)) \/ float(steps);\r\n\r\n        \/\/ Add ambient\r\n        float ambient = 0.7;\r\n        lighting = ambient + (1.0 - ambient) * diffuse;\r\n    }\r\n\r\n    return hit ? sceneColor * lighting : sceneColor;\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) \/ u_resolution.y;\r\n    vec3 col = vec3(0.0);\r\n\r\n    Transform cameraTransform = defaultTransform();\r\n    cameraTransform.position = u_camPos;\r\n    vec3 rayDir = rot3D(normalize(vec3(uv, 1.0)), u_camRot);\r\n\r\n    \/\/ the actual raymarching\r\n    float rayDistance = 0.0;\r\n    vec3 hitPos;\r\n    int i;\r\n    for(i = 0; i < 100; i++){\r\n        hitPos = cameraTransform.position + rayDir * rayDistance;\r\n        float distance = scene(hitPos);\r\n        rayDistance += distance;\r\n        if(distance < u_camNear || rayDistance > u_camFar) break;\r\n    }\r\n\r\n    \/\/ Base color from depth, and add shading\r\n    col = palette(rayDistance \/ u_camFar * 2.5);\r\n    col = shadeScene(col, hitPos, rayDir, rayDistance);\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}"
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "glsl",
        "section-code": "precision highp float;\r\n\r\n\/\/ variables passed from the scene manager\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\nuniform vec3 u_camPos;\r\nuniform vec3 u_camRot;\r\nuniform float u_camNear;\r\nuniform float u_camFar;\r\nuniform float u_scrollModifier;\r\n\r\n\/\/ basic structure to save data about an object\r\nstruct Transform {\r\n    vec3 position;\r\n    vec3 rotation;\r\n    vec3 scale;\r\n};\r\n\r\nTransform defaultTransform() {\r\n    Transform t;\r\n    t.position = vec3(0.0);\r\n    t.rotation = vec3(0.0);\r\n    t.scale = vec3(1.0);\r\n    return t;\r\n}\r\n\r\n\/\/ logic handling object rotation\r\nvec3 rotateX(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\r\n}\r\n\r\nvec3 rotateZ(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\r\n}\r\n\r\nvec3 rot3D(vec3 p, vec3 rot) {\r\n    p = rotateX(p, rot.x);\r\n    p = rotateY(p, rot.y);\r\n    p = rotateZ(p, rot.z);\r\n    return p;\r\n}\r\n\r\nvec3 applyTransform(vec3 pos, Transform t) {\r\n    pos -= t.position;\r\n    pos = rot3D(pos, t.rotation);\r\n    pos \/= t.scale;\r\n    return pos;\r\n}\r\n\r\n\/\/ SDF's for specific shapes\r\nfloat sdSphere(vec3 p, float s) {\r\n    return length(p) - s;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\n\/\/ operators to combine 2 objects\r\nfloat opSmoothUnion(float d1, float d2, float k) {\r\n    float h = clamp(0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0);\r\n    return mix(d2, d1, h) - k*h*(1.0-h);\r\n}\r\n\r\n\/\/ color pallete\r\nvec3 palette(float t) {\r\n    vec3 a = vec3(0.681, 0.768, 0.968);\r\n    vec3 b = vec3(0.245, 0.764, 0.721);\r\n    vec3 c = vec3(1.202, 0.362, 0.660);\r\n    vec3 d = vec3(0.481, 3.592, 5.705);\r\n    return a + b*cos(6.283185*(c*t + d));\r\n}\r\n\r\n\r\n\/\/ returns the local position inside the cell (centered around 0)\r\n\/\/ and outputs the integer cell ID\r\nvec3 fractCell(vec3 worldPos, float cellSize, out vec3 cellId) {\r\n    vec3 scaledPos = worldPos \/ cellSize;\r\n    cellId = floor(scaledPos);\r\n    return fract(scaledPos) * cellSize - cellSize * 0.5;\r\n}\r\n\r\n\r\n\/\/ Helper to get a random value based on a position\r\nfloat randomValue(vec3 cellId) {\r\n    cellId = fract(cellId * 0.3183099 + 0.1);\r\n    cellId *= 17.0;\r\n    return fract(cellId.x * cellId.y * cellId.z * (cellId.x + cellId.y + cellId.z));\r\n}\r\n\r\n\/\/ create the object that is repeated across the scene\r\nfloat cubeSphere(vec3 worldPos) {\r\n    Transform boxTransform = defaultTransform();\r\n    vec3 cellId;\r\n    float cellSize = 2.0 * u_scrollModifier;\r\n\r\n    \/\/ get repeated local position and cell id\r\n    vec3 repeatedPos = fractCell(worldPos + vec3(0.0, 0.0, u_time), cellSize, cellId);\r\n\r\n    \/\/ random size per cell\r\n    float randSize = randomValue(cellId);\r\n    float size = 0.4 + randSize * 0.1;\r\n\r\n    \/\/ random rotation per cell\r\n    boxTransform.rotation = vec3(\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0\r\n    );\r\n\r\n    vec3 localPos = applyTransform(repeatedPos, boxTransform);\r\n    float box = sdBox(localPos, vec3(size));\r\n    float sphere = sdSphere(localPos, size);\r\n\r\n    \/\/ smooth saw tooth sine\r\n    float sine = sin(u_time * 6.283185 \/ 8.0);\r\n    float y = tanh(sine * 5.0) * 0.5 + 0.5;\r\n    \r\n    return mix(box, sphere, y);\r\n}\r\n\r\n\/\/ holds the entire scene to do raymarching on\r\nfloat scene(vec3 worldPos) {\r\n    Transform sphereTransform = defaultTransform();\r\n    float sphere = sdSphere(applyTransform(worldPos, sphereTransform), 1.0);\r\n\r\n    float cubeSphere = cubeSphere(worldPos); \r\n\r\n    return opSmoothUnion(sphere, cubeSphere, 0.4);\r\n}\r\n\r\n\/\/ Estimate gradient (normal) of the SDF at a point within the scene\r\nvec3 estimateNormal(vec3 p) {\r\n    float eps = 0.001;\r\n    float dx = scene(p + vec3(eps, 0.0, 0.0)) - scene(p - vec3(eps, 0.0, 0.0));\r\n    float dy = scene(p + vec3(0.0, eps, 0.0)) - scene(p - vec3(0.0, eps, 0.0));\r\n    float dz = scene(p + vec3(0.0, 0.0, eps)) - scene(p - vec3(0.0, 0.0, eps));\r\n    return normalize(vec3(dx, dy, dz));\r\n}\r\n\r\n\/\/ handles the shading of the scene, in a toony style\r\nvec3 shadeScene(vec3 sceneColor, vec3 hitPos, vec3 rayDir, float rayDistance) {\r\n    vec3 normal = vec3(0.0);\r\n    vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\r\n    float lighting = 1.0;\r\n\r\n    bool hit = (rayDistance < u_camFar);\r\n    if(hit) {\r\n        normal = estimateNormal(hitPos);\r\n\r\n        \/\/ Lambertian shading\r\n        float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\r\n\r\n        int steps = 3;\r\n        diffuse = floor(diffuse * float(steps)) \/ float(steps);\r\n\r\n        \/\/ Add ambient\r\n        float ambient = 0.7;\r\n        lighting = ambient + (1.0 - ambient) * diffuse;\r\n    }\r\n\r\n    return hit ? sceneColor * lighting : sceneColor;\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) \/ u_resolution.y;\r\n    vec3 col = vec3(0.0);\r\n\r\n    Transform cameraTransform = defaultTransform();\r\n    cameraTransform.position = u_camPos;\r\n    vec3 rayDir = rot3D(normalize(vec3(uv, 1.0)), u_camRot);\r\n\r\n    \/\/ the actual raymarching\r\n    float rayDistance = 0.0;\r\n    vec3 hitPos;\r\n    int i;\r\n    for(i = 0; i < 100; i++){\r\n        hitPos = cameraTransform.position + rayDir * rayDistance;\r\n        float distance = scene(hitPos);\r\n        rayDistance += distance;\r\n        if(distance < u_camNear || rayDistance > u_camFar) break;\r\n    }\r\n\r\n    \/\/ Base color from depth, and add shading\r\n    col = palette(rayDistance \/ u_camFar * 2.5);\r\n    col = shadeScene(col, hitPos, rayDir, rayDistance);\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}"
      }
    ]
  },
  {
    "title": "Howling moon",
    "subtitle": "Dark toon card game",
    "thumbnail": "Projects/HowlingMoon/Thumbnail.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "Howling moon is a solo school project i worked on for ~3 weeks, i made the game logic, all 3D assets and more.\n\nThe goal of the game is to fight, gather stronger cards by summoning them with currency.\n\nThe main game functions were done by the end of the project, but balancing and refining the loop to feel more rewarding weren't achievable.",
        "section-image": "Projects/HowlingMoon/Thumbnail.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/HowlingMoon/Thumbnail.png",
          "Projects/HowlingMoon/Summoning.png",
          "Projects/HowlingMoon/Combat.png"
        ]
      },
      {
        "?section-name": "video",
        "?section-icon": "Images/Icons/education.png",
        "section-poster": "Projects/Combat.png",
        "section-video": "Projects/2025-11-15_00-55-33.mp4"
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "CSharp",
        "section-code": "precision highp float;\r\n\r\n\/\/ variables passed from the scene manager\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\nuniform vec3 u_camPos;\r\nuniform vec3 u_camRot;\r\nuniform float u_camNear;\r\nuniform float u_camFar;\r\nuniform float u_scrollModifier;\r\n\r\n\/\/ basic structure to save data about an object\r\nstruct Transform {\r\n    vec3 position;\r\n    vec3 rotation;\r\n    vec3 scale;\r\n};\r\n\r\nTransform defaultTransform() {\r\n    Transform t;\r\n    t.position = vec3(0.0);\r\n    t.rotation = vec3(0.0);\r\n    t.scale = vec3(1.0);\r\n    return t;\r\n}\r\n\r\n\/\/ logic handling object rotation\r\nvec3 rotateX(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\r\n}\r\n\r\nvec3 rotateZ(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\r\n}\r\n\r\nvec3 rot3D(vec3 p, vec3 rot) {\r\n    p = rotateX(p, rot.x);\r\n    p = rotateY(p, rot.y);\r\n    p = rotateZ(p, rot.z);\r\n    return p;\r\n}\r\n\r\nvec3 applyTransform(vec3 pos, Transform t) {\r\n    pos -= t.position;\r\n    pos = rot3D(pos, t.rotation);\r\n    pos \/= t.scale;\r\n    return pos;\r\n}\r\n\r\n\/\/ SDF's for specific shapes\r\nfloat sdSphere(vec3 p, float s) {\r\n    return length(p) - s;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\n\/\/ operators to combine 2 objects\r\nfloat opSmoothUnion(float d1, float d2, float k) {\r\n    float h = clamp(0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0);\r\n    return mix(d2, d1, h) - k*h*(1.0-h);\r\n}\r\n\r\n\/\/ color pallete\r\nvec3 palette(float t) {\r\n    vec3 a = vec3(0.681, 0.768, 0.968);\r\n    vec3 b = vec3(0.245, 0.764, 0.721);\r\n    vec3 c = vec3(1.202, 0.362, 0.660);\r\n    vec3 d = vec3(0.481, 3.592, 5.705);\r\n    return a + b*cos(6.283185*(c*t + d));\r\n}\r\n\r\n\r\n\/\/ returns the local position inside the cell (centered around 0)\r\n\/\/ and outputs the integer cell ID\r\nvec3 fractCell(vec3 worldPos, float cellSize, out vec3 cellId) {\r\n    vec3 scaledPos = worldPos \/ cellSize;\r\n    cellId = floor(scaledPos);\r\n    return fract(scaledPos) * cellSize - cellSize * 0.5;\r\n}\r\n\r\n\r\n\/\/ Helper to get a random value based on a position\r\nfloat randomValue(vec3 cellId) {\r\n    cellId = fract(cellId * 0.3183099 + 0.1);\r\n    cellId *= 17.0;\r\n    return fract(cellId.x * cellId.y * cellId.z * (cellId.x + cellId.y + cellId.z));\r\n}\r\n\r\n\/\/ create the object that is repeated across the scene\r\nfloat cubeSphere(vec3 worldPos) {\r\n    Transform boxTransform = defaultTransform();\r\n    vec3 cellId;\r\n    float cellSize = 2.0 * u_scrollModifier;\r\n\r\n    \/\/ get repeated local position and cell id\r\n    vec3 repeatedPos = fractCell(worldPos + vec3(0.0, 0.0, u_time), cellSize, cellId);\r\n\r\n    \/\/ random size per cell\r\n    float randSize = randomValue(cellId);\r\n    float size = 0.4 + randSize * 0.1;\r\n\r\n    \/\/ random rotation per cell\r\n    boxTransform.rotation = vec3(\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0\r\n    );\r\n\r\n    vec3 localPos = applyTransform(repeatedPos, boxTransform);\r\n    float box = sdBox(localPos, vec3(size));\r\n    float sphere = sdSphere(localPos, size);\r\n\r\n    \/\/ smooth saw tooth sine\r\n    float sine = sin(u_time * 6.283185 \/ 8.0);\r\n    float y = tanh(sine * 5.0) * 0.5 + 0.5;\r\n    \r\n    return mix(box, sphere, y);\r\n}\r\n\r\n\/\/ holds the entire scene to do raymarching on\r\nfloat scene(vec3 worldPos) {\r\n    Transform sphereTransform = defaultTransform();\r\n    float sphere = sdSphere(applyTransform(worldPos, sphereTransform), 1.0);\r\n\r\n    float cubeSphere = cubeSphere(worldPos); \r\n\r\n    return opSmoothUnion(sphere, cubeSphere, 0.4);\r\n}\r\n\r\n\/\/ Estimate gradient (normal) of the SDF at a point within the scene\r\nvec3 estimateNormal(vec3 p) {\r\n    float eps = 0.001;\r\n    float dx = scene(p + vec3(eps, 0.0, 0.0)) - scene(p - vec3(eps, 0.0, 0.0));\r\n    float dy = scene(p + vec3(0.0, eps, 0.0)) - scene(p - vec3(0.0, eps, 0.0));\r\n    float dz = scene(p + vec3(0.0, 0.0, eps)) - scene(p - vec3(0.0, 0.0, eps));\r\n    return normalize(vec3(dx, dy, dz));\r\n}\r\n\r\n\/\/ handles the shading of the scene, in a toony style\r\nvec3 shadeScene(vec3 sceneColor, vec3 hitPos, vec3 rayDir, float rayDistance) {\r\n    vec3 normal = vec3(0.0);\r\n    vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\r\n    float lighting = 1.0;\r\n\r\n    bool hit = (rayDistance < u_camFar);\r\n    if(hit) {\r\n        normal = estimateNormal(hitPos);\r\n\r\n        \/\/ Lambertian shading\r\n        float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\r\n\r\n        int steps = 3;\r\n        diffuse = floor(diffuse * float(steps)) \/ float(steps);\r\n\r\n        \/\/ Add ambient\r\n        float ambient = 0.7;\r\n        lighting = ambient + (1.0 - ambient) * diffuse;\r\n    }\r\n\r\n    return hit ? sceneColor * lighting : sceneColor;\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) \/ u_resolution.y;\r\n    vec3 col = vec3(0.0);\r\n\r\n    Transform cameraTransform = defaultTransform();\r\n    cameraTransform.position = u_camPos;\r\n    vec3 rayDir = rot3D(normalize(vec3(uv, 1.0)), u_camRot);\r\n\r\n    \/\/ the actual raymarching\r\n    float rayDistance = 0.0;\r\n    vec3 hitPos;\r\n    int i;\r\n    for(i = 0; i < 100; i++){\r\n        hitPos = cameraTransform.position + rayDir * rayDistance;\r\n        float distance = scene(hitPos);\r\n        rayDistance += distance;\r\n        if(distance < u_camNear || rayDistance > u_camFar) break;\r\n    }\r\n\r\n    \/\/ Base color from depth, and add shading\r\n    col = palette(rayDistance \/ u_camFar * 2.5);\r\n    col = shadeScene(col, hitPos, rayDir, rayDistance);\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}"
      }
    ],
    "links": [
      {
        "name": "Itch.io",
        "icon": "Images/Logos/itchio.svg",
        "link": "https://lyritha.itch.io/howling-moon"
      }
    ]
  }
]
