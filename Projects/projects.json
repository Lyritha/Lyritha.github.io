[
  {
    "title": "The Filth",
    "subtitle": "90's desktop bullet hell.",
    "thumbnail": "Projects/TheFilth/TheFilth_preview.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "The Filth is a space shooter-like game made during a gamejam with the theme: \"Making free space\", where you have to shoot at files to destroy them, and survive their attacks. \n\nAs the player you can shoot projectiles to destroy enemies, and also have access to a special attack that hurts multiple enemies.",
        "section-image": "Projects/TheFilth/TheFilth_preview.png"
      },
      {
        "?section-name": "contribution",
        "?section-icon": "Images/Icons/briefcase.png",
        "section-description": "In this project my role was SCRUM master and lead developer. \n\nI focused on integrating game systems that the other group members made, but also made my own systems like the spawning grid. I also made the UI of the game.",
        "section-image": "Projects/TheFilth/TheFilth_preview2.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/TheFilth/TheFilth_preview.png",
          "Projects/TheFilth/TheFilth_sprites.png",
          "Projects/TheFilth/TheFilth_preview2.png"
        ]
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "csharp",
        "section-code": "\/\/\/ Controls the \"eye\" in the center of the screen. \r\n\/\/\/ it either looks at the player or a random points on screen, \r\n\/\/\/ switching targets at random intervals.\r\n\r\nusing System.Collections;\r\nusing UnityEngine;\r\n\r\npublic class TheFilthLook : MonoBehaviour\r\n{\r\n    [SerializeField] \r\n    private GameObject eye = null;\r\n    [SerializeField]\r\n    private float minDistanceFromPlayer = 0.5f;\r\n    [SerializeField]\r\n    private Vector2 TargetSwitchDelay = Vector2.zero;\r\n    [SerializeField]\r\n    private float lookSpeed = 5f;\r\n\r\n    private Transform playerT = null;\r\n    private float minX, maxX, minY, maxY = 0;\r\n    private bool isFollowingPlayer = false;\r\n    private Vector2 target = Vector2.zero;\r\n\r\n    void Start()\r\n    {\r\n        playerT = GameObject.FindGameObjectWithTag(\"Player\").transform;\r\n\r\n        \/\/ensures the eye chooses a point that's actually on the screen.\r\n        Vector2 bottomLeft = Camera.main.ViewportToWorldPoint(Vector2.zero);\r\n        Vector2 topRight = Camera.main.ViewportToWorldPoint(Vector2.one);\r\n\r\n        minX = bottomLeft.x;\r\n        minY = bottomLeft.y;\r\n        maxX = topRight.x;\r\n        maxY = topRight.y;\r\n\r\n        target = transform.position;\r\n        StartCoroutine(ChooseTarget());\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        \/\/\/ calculates the point where the eye needs to move to, \r\n        \/\/\/ limited to a radius from the root object.\r\n        Vector2 dir = target - (Vector2)transform.position;\r\n        float distance = dir.magnitude;\r\n\r\n        if (distance > 0f)\r\n        {\r\n            dir \/= distance;\r\n        }\r\n\r\n        dir *= minDistanceFromPlayer;\r\n\r\n        if (isFollowingPlayer && distance > minDistanceFromPlayer)\r\n        {\r\n            target = playerT.position;\r\n        }\r\n\r\n        \/\/ actually move the eye, smoothly\r\n        eye.transform.position = Vector2.Lerp\r\n            (\r\n                eye.transform.position,\r\n                (Vector2)transform.position + dir,\r\n                Time.deltaTime * lookSpeed\r\n            );\r\n    }\r\n\r\n    IEnumerator ChooseTarget()\r\n    {\r\n        \/\/ delay to avoid it moving at the start.\r\n        yield return new WaitForSecondsRealtime(10f);\r\n\r\n        \/\/ not save, but okay for a gamejam game.\r\n        while (true)\r\n        {\r\n            float minDelay = TargetSwitchDelay.x;\r\n            float maxDelay = TargetSwitchDelay.y;\r\n\r\n            if (isFollowingPlayer)\r\n            {\r\n                minDelay += 5;\r\n                maxDelay += 5;\r\n            }\r\n\r\n            float randomDelay = Random.Range(minDelay, maxDelay);\r\n            yield return new WaitForSecondsRealtime(randomDelay);\r\n\r\n            isFollowingPlayer = Random.value < 0.5f;\r\n\r\n            if (!isFollowingPlayer)\r\n            {\r\n                target = ChooseRandomLookTarget();\r\n            }\r\n        }\r\n    }\r\n\r\n    Vector2 ChooseRandomLookTarget()\r\n    {\r\n        Vector2 target = Vector2.zero;\r\n\r\n        target.x = Random.Range(minX, maxX);\r\n        target.y = Random.Range(minY, maxY);\r\n\r\n        return target;\r\n    }\r\n}\r\n"
      }
    ],
    "links": [
      {
        "name": "Github",
        "icon": "Images/Logos/Github.png",
        "link": "https://github.com/Lyritha/TheFilth/releases/tag/GameJam-Release"
      },
      {
        "name": "UnityPlay",
        "icon": "Images/Logos/unity.png",
        "link": "https://play.unity.com/en/games/b90b0494-ef42-4095-bdf8-ac9bbe0ff9be/the-filth"
      }
    ]
  },
  {
    "title": "Cyberpunk gun",
    "subtitle": "model made for fun",
    "thumbnail": "Projects/gun/weapon.png",
    "data-filter": "Blender",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "I made this model as a side project for myself, I slowly worked on it over the course of around 2 months i spend a bit of time on it every so often.\n\nI used no reference images to make this model as a challenge for myself.",
        "section-image": "Projects/gun/weapon.png"
      },
      {
        "?section-name": "3D model",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-scene": {
          "path": "Projects/gun/Gun.glb",
          "hdrPathOrHex": "Images/skyboxes/night_sky.hdr",
          "cameraPosition": [ -1.98, 2.29, 5.07 ],
          "cameraRotation": [ -0.27, -0.25, -0.07 ],
          "cameraTarget": [ -0.58, 0.82, -0.26 ],
          "cameraZoom": {
            "min": 0.1,
            "max": 10,
            "current": 7
          }
        }
      }
    ]
  },
  {
    "title": "Towaria",
    "subtitle": "A voxel based tower defense.",
    "thumbnail": "Projects/Towaria/towaria_preview.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "Towaria is a challenging tower defense game where letting enemies reach the end means defeat. \n\nPlace auto-firing towers to eliminate all enemies and advance through waves. Survive the final wave to move on to the next level.",
        "section-image": "Projects/Towaria/towaria_preview.png"
      },
      {
        "?section-name": "contribution",
        "?section-icon": "Images/Icons/briefcase.png",
        "section-description": "I focused on core game mechanics, like tower placement and stats. \n\nI also contributed to 3D models (ground tiles, a tower, enemies) and helped polish the UI to ensure visual consistency after functionality was implemented.",
        "section-image": "Projects/Towaria/towaria_preview2.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/Towaria/towaria_preview.png",
          "Projects/Towaria/towaria_preview2.png",
          "Projects/Towaria/towaria_3d_models.png"
        ]
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "csharp",
        "section-code": "\/\/\/ This script manages the movement of every enemy.  \r\n\/\/\/ Add an enemy to the list if you want it to be controlled by this script,  \r\n\/\/\/ remove it when you want it to stop being controlled by this script.\r\n\r\nusing UnityEngine;\r\nusing Unity.Jobs;\r\nusing Unity.Burst;\r\nusing Unity.Collections;\r\nusing UnityEngine.Jobs;\r\nusing System.Collections.Generic;\r\n\r\npublic class EnemyMovementSystem : MonoBehaviour\r\n{\r\n    \/\/ Enemies hold all enemies. enemiesToUpdate is a list of all enemies used in the current job,\r\n    \/\/ to avoid shifting list issues.\r\n    private readonly List<EnemyBase> enemies = new();\r\n    private List<EnemyBase> enemiesToUpdate = new();\r\n\r\n    \/\/ Store some values to avoid having to call pathCreator more than needed.\r\n    public Vector3 PathStart { get; private set; }\r\n    private int pathReachedEndIndex;\r\n\r\n    \/\/ Data to pass on to job. Native arrays are required when using jobs (multithreading).\r\n    private TransformAccessArray enemyTransforms;\r\n    private NativeArray<Vector3> pathNodes;\r\n    private NativeArray<float> speeds;\r\n    private NativeArray<Vector3> offsets;\r\n    private NativeArray<int> targetNodeIndices;\r\n    private CreateAIPath pathCreator;\r\n    \/\/ Stores a reference to the job itself.\r\n    private JobHandle jobHandle;\r\n    private bool jobAlreadyCompleted = false;\r\n\r\n    \/\/ Allow enemy to add and remove itself to the movement job.\r\n    public void AddEnemy(EnemyBase enemy) => enemies.Add(enemy);\r\n    public void RemoveEnemy(EnemyBase enemy) => enemies.Remove(enemy);\r\n\r\n    private void Start()\r\n    {\r\n        pathCreator = FindFirstObjectByType<CreateAIPath>();\r\n        pathCreator.RegeneratedPaths += InitializePathNodes;\r\n    }\r\n\r\n    public void InitializePathNodes()\r\n    {\r\n        PathStart = pathCreator.Path[0];\r\n        pathReachedEndIndex = pathCreator.Path.Count;\r\n\r\n        \/\/ Dispose the pathNodes if it has already been created.\r\n        if (pathNodes.IsCreated)\r\n        {\r\n            jobHandle.Complete();\r\n            pathNodes.Dispose();\r\n        }\r\n\r\n        pathNodes = new NativeArray<Vector3>(pathCreator.Path.ToArray(), Allocator.Persistent);\r\n    }\r\n\r\n    \/\/ Called after update functions have been called.\r\n    private void Update()\r\n    {\r\n        \/\/ If the job is completed, complete the job,\r\n        \/\/ write some data to the AI and create a new job.\r\n        if (jobHandle.IsCompleted)\r\n        {\r\n            \/\/ Force job to complete.\r\n            jobHandle.Complete();\r\n\r\n            \/\/ If this is the first time this job has been marked as completed, run this code,\r\n            \/\/ to avoid unnecessary repeated writing to the enemies.\r\n            if (!jobAlreadyCompleted)\r\n            {\r\n                \/\/ Mark this job as already completed once.\r\n                jobAlreadyCompleted = true;\r\n\r\n                \/\/ Check if the enemy count is greater than 0,\r\n                \/\/ and if all the arrays are created (by checking the main one).\r\n                if (enemiesToUpdate.Count > 0 && enemyTransforms.isCreated)\r\n                {\r\n                    \/\/ Update target indices of the enemies using information from the job.\r\n                    for (int i = 0; i < enemiesToUpdate.Count; i++)\r\n                    {\r\n                        enemiesToUpdate[i].TargetNodeIndex = targetNodeIndices[i];\r\n                        if (enemiesToUpdate[i].TargetNodeIndex >= pathReachedEndIndex)\r\n                        {\r\n                            enemiesToUpdate[i].HasReachedEnd();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \/\/ Dispose of the data that changes between jobs to free up space.\r\n                DisposeMost();\r\n            }\r\n\r\n            \/\/ Create and run a new job only if there are enemies present.\r\n            if (enemies.Count > 0)\r\n            {\r\n                jobAlreadyCompleted = false;\r\n                jobHandle = CreateJobData().Schedule(enemyTransforms);\r\n            }\r\n        }\r\n    }\r\n\r\n    public EnemyMoveJob CreateJobData()\r\n    {\r\n        enemiesToUpdate = new(enemies);\r\n\r\n        \/\/ Create new native arrays with the length of enemies.\r\n        enemyTransforms = new TransformAccessArray(enemiesToUpdate.Count);\r\n        speeds = new NativeArray<float>(enemiesToUpdate.Count, Allocator.Persistent);\r\n        offsets = new NativeArray<Vector3>(enemiesToUpdate.Count, Allocator.Persistent);\r\n        targetNodeIndices = new NativeArray<int>(enemiesToUpdate.Count, Allocator.Persistent);\r\n\r\n        \/\/ Fill all the native arrays in a single for loop,\r\n        \/\/ skip hasReachedEnd because we fill it with false for every enemy.\r\n        for (int i = 0; i < enemiesToUpdate.Count; i++)\r\n        {\r\n            EnemyBase enemy = enemiesToUpdate[i];\r\n            enemyTransforms.Add(enemy.transform);\r\n            speeds[i] = enemy.Speed;\r\n            offsets[i] = enemy.RandomOffset;\r\n            targetNodeIndices[i] = enemy.TargetNodeIndex;\r\n        }\r\n\r\n        \/\/ Return the data as an EnemyMoveJob struct,\r\n        \/\/ this needs to be filled in fully, otherwise the job gets angry.\r\n        return new()\r\n        {\r\n            DeltaTime = Time.deltaTime,\r\n            PathNodes = pathNodes,\r\n            Speeds = speeds,\r\n            Offsets = offsets,\r\n            TargetNodeIndices = targetNodeIndices,\r\n        };\r\n    }\r\n\r\n    \/\/ Dispose of everything when this object is destroyed,\r\n    \/\/ otherwise unnecessary memory is used.\r\n    private void OnDestroy()\r\n    {\r\n        jobHandle.Complete();\r\n        DisposeMost();\r\n        if (pathNodes.IsCreated) pathNodes.Dispose();\r\n    }\r\n\r\n    \/\/\/ <summary>\r\n    \/\/\/ Dispose of data that changes between jobs to free up space.\r\n    \/\/\/ Garbage collection doesn't happen automatically on native arrays;\r\n    \/\/\/ you have to dispose of them yourself, otherwise you will get a memory leak.\r\n    \/\/\/ <\/summary>\r\n    private void DisposeMost()\r\n    {\r\n        if (enemyTransforms.isCreated) enemyTransforms.Dispose();\r\n        if (speeds.IsCreated) speeds.Dispose();\r\n        if (offsets.IsCreated) offsets.Dispose();\r\n        if (targetNodeIndices.IsCreated) targetNodeIndices.Dispose();\r\n    }\r\n}\r\n\r\n\/\/ Burst compiler, very efficient, but limited Unity functions.\r\n\/\/ Also garbage collection needs to be done by yourself.\r\n[BurstCompile]\r\npublic struct EnemyMoveJob : IJobParallelForTransform\r\n{\r\n    \/\/ Data as a struct. When you don't want a job to modify data,\r\n    \/\/ make sure it's set to readonly.\r\n    [ReadOnly] public float DeltaTime;\r\n    [ReadOnly] public NativeArray<Vector3> PathNodes;\r\n    [ReadOnly] public NativeArray<float> Speeds;\r\n    [ReadOnly] public NativeArray<Vector3> Offsets;\r\n    public NativeArray<int> TargetNodeIndices;\r\n\r\n    \/\/ Move every object with its own data.\r\n    public void Execute(int index, TransformAccess transform)\r\n    {\r\n        \/\/ If target index is too big, just don't.\r\n        if (TargetNodeIndices[index] >= PathNodes.Length)\r\n        {\r\n            Debug.LogWarning($\"Target index of enemy {index} was out of range of the path.\");\r\n            return;\r\n        }\r\n\r\n        \/\/ Get the information for this specific index.\r\n        float speed = Speeds[index];\r\n        Vector3 offset = Offsets[index];\r\n        int targetNodeIndex = TargetNodeIndices[index];\r\n\r\n        \/\/ If target index is 0 (at the start of the path),\r\n        \/\/ position at the beginning and increment the target position.\r\n        if (targetNodeIndex == 0)\r\n        {\r\n            transform.SetPositionAndRotation(PathNodes[targetNodeIndex], Quaternion.identity);\r\n            targetNodeIndex++;\r\n            TargetNodeIndices[index] = targetNodeIndex;\r\n        }\r\n\r\n        \/\/ Save the current and target position.\r\n        Vector3 currentPosition = transform.position;\r\n        Vector3 targetPosition = PathNodes[targetNodeIndex] + offset;\r\n\r\n        \/\/ Update the transform based on the distance you need to go.\r\n        transform.position = Vector3.MoveTowards(currentPosition, targetPosition, speed * DeltaTime);\r\n\r\n        \/\/ Check if needs to be rotated, if so rotate.\r\n        Vector3 direction = (targetPosition - currentPosition).normalized;\r\n        \/\/ If there's a valid direction, rotate smoothly.\r\n        if (direction.sqrMagnitude > 0.0001f) \/\/ Avoid division by zero and insignificant values.\r\n        {\r\n            \/\/ Get the target rotation based on the direction.\r\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\r\n            \/\/ Smoothly rotate from current rotation to target rotation.\r\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 5 * DeltaTime);\r\n        }\r\n\r\n        \/\/ Check if enemy has reached the target node with a tolerance.\r\n        if (Vector3.Distance(transform.position, targetPosition) <= 0.01f) TargetNodeIndices[index]++;\r\n    }\r\n}\r\n"
      }
    ],
    "links": [
      {
        "name": "Github",
        "icon": "Images/Logos/Github.png",
        "link": "https://github.com/Egg321123/J2P1_microgame/releases/tag/prototype-03"
      },
      {
        "name": "Direct",
        "icon": "Images/Icons/download.png",
        "link": "https://github.com/Egg321123/J2P1_microgame/releases/download/prototype-03/Towaria.apk"
      }
    ]
  },
  {
    "title": "SDF shader",
    "subtitle": "Shader made using glsl",
    "thumbnail": "Projects/Shaders/Fractel.png",
    "data-filter": "Shaders",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "This is the second project i made for my self-study task for my study, using various youtube video's to slowly learn GLSL. \n\nThe original shader was made to work within Shadertoy but had to be slightly modified to work on this website.",
        "section-image": "Projects/Shaders/Fractel.png"
      },
      {
        "?section-name": "Shader",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-shader-shadertoy": "precision mediump float;\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(1.088, 0.928, 0.928);\n    vec3 b = vec3(0.478, 0.848, 0.638);\n    vec3 c = vec3(0.903, 0.668, 0.608);\n    vec3 d = vec3(1.067, 0.797, 0.528);\n\n    return a + b * cos(6.283185 * (c * t + d));\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for(int i = 0; i < 3; i++) {\n        float fi = float(i);\n        vec3 col = vec3(0.0);\n\n        if(mod(fi, 2.0) == 0.0) col = palette(length(uv0) + fi * 0.4 + u_time / 2.0);\n        else col = palette(length(uv0) + fi * 0.4 - u_time / 2.0);\n\n        uv = fract(uv * 1.7) - 0.5;\n        float dist = length(uv);\n        float frequency = 10.0;\n\n        if(mod(fi, 2.0) == 0.0) dist = sin(dist * frequency + u_time) / frequency;\n        else dist = sin(dist * frequency - u_time) / frequency;\n\n        dist = abs(dist);\n        dist = 0.005 / dist;\n\n        finalColor += col * dist;\n    }\n\n    gl_FragColor = vec4(finalColor, 1.0);\n}"
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "glsl",
        "section-code": "// cosine based palette, 4 vec3 params\nvec3 palette(float t) {\n    vec3 a = vec3(1.088, 0.928, 0.928);\n    vec3 b = vec3(0.478, 0.848, 0.638);\n    vec3 c = vec3(0.903, 0.668, 0.608);\n    vec3 d = vec3(1.067, 0.797, 0.528);\n    return a + b*cos(6.283185*(c*t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for(float i = 0.0; i < 3.0; i++) {\n        vec3 col = vec3(0.0);\n        if(mod(i, 2.0) == 0.0) col = palette(length(uv0) + i*0.4 + iTime/2.0);\n        else col = palette(length(uv0) + i*0.4 - iTime/2.0);\n\n        uv = fract(uv * 1.7) - 0.5;\n        float dist = length(uv);\n        float frequency = 10.0;\n\n        if(mod(i, 2.0) == 0.0) dist = sin(dist * frequency + iTime) / frequency;\n        else dist = sin(dist * frequency - iTime) / frequency;\n\n        dist = abs(dist);\n        dist = 0.005 / dist;\n\n        finalColor += col * dist;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}"
      }
    ]
  },
  {
    "title": "Tiny house",
    "subtitle": "A small cozy house",
    "thumbnail": "Projects/TinyHouse/Hous_Front.png",
    "data-filter": "Blender",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "A to-scale tiny house created in Blender. Everything in the scene was modeled by me, except for the grass. \n\nThis 3D model was made for a school assignment for my software development degree.",
        "section-image": "Projects/TinyHouse/Hous_Top.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Projects/TinyHouse/Hous_Front.png",
          "Projects/TinyHouse/Hous_Top.png",
          "Projects/TinyHouse/Hous_Back.png",
          "Projects/TinyHouse/Hous_BedRoom.png",
          "Projects/TinyHouse/Hous_Bathroom.png"
        ]
      },
      {
        "?section-name": "3D model",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-scene": {
          "path": "Projects/TinyHouse/House.glb",
          "boundsName": "House",
          "hdrPathOrHex": "Images/skyboxes/day_sky.hdr",
          "cameraPosition": [ -3.39, 2.52, 3.52 ],
          "cameraRotation": [ -0.4, -0.74, -0.28 ],
          "cameraTarget": [ -0.01, 0.52, 0.01 ],
          "cameraZoom": {
            "min": 0.1,
            "max": 6.5,
            "current": 5.2
          }
        }
      }
    ]
  },
  {
    "title": "Ray Marching",
    "subtitle": "Shader made using glsl",
    "thumbnail": "Projects/Shaders/RayMarching.png",
    "data-filter": "Shaders",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "The third project i made for my self-study task for my study, as i've always loved raymarched geometry i wanted to try and make it myself. \n\nThe original shader was made to work within Shadertoy but had to be slightly modified to work on this website.",
        "section-image": "Projects/Shaders/RayMarching.png"
      },
      {
        "?section-name": "Shader",
        "?section-icon": "Images/Icons/dimensions.png",
        "section-shader-shadertoy": "precision mediump float;\n\nuniform vec2 u_resolution;\n\nstruct Transform {\n    vec3 position;\n    vec3 rotation;\n    vec3 scale;\n};\n\nTransform defaultTransform() {\n    Transform t;\n    t.position = vec3(0.0, 0.0, 0.0);\n    t.rotation = vec3(0.0, 0.0, 0.0);\n    t.scale = vec3(1.0, 1.0, 1.0);\n    return t;\n}\n\nvec3 rot3D(vec3 pos, vec3 rot) {\n    float yaw = radians(rot.y);\n    float pitch = radians(rot.x);\n    float roll = radians(rot.z);\n\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    );\n\n    mat3 rotY = mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    );\n\n    mat3 rotZ = mat3(\n        cos(roll), -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    return rotZ * rotY * rotX * pos;\n}\n\nvec3 applyTransform(vec3 pos, Transform transform) {\n    pos = pos - transform.position;\n    pos = rot3D(pos, transform.rotation);\n    pos = pos / transform.scale;\n    return pos;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.681, 0.768, 0.968);\n    vec3 b = vec3(0.245, 0.764, 0.721);\n    vec3 c = vec3(1.202, 0.362, 0.660);\n    vec3 d = vec3(0.481, 3.592, 5.705);\n    return a + b*cos(6.283185*(c*t + d));\n}\n\nvec3 repeat(vec3 p, vec3 c) {\n    return mod(p, c) - 0.5 * c;\n}\n\nfloat scene(vec3 worldPos) {\n    Transform sphereTransform = defaultTransform();\n    float sphere = sdSphere(applyTransform(worldPos, sphereTransform), 1.0);\n\n    Transform boxTransform = defaultTransform();\n    vec3 repeatedPos = repeat(worldPos, vec3(1.0));\n    float box = sdBox(applyTransform(repeatedPos, boxTransform), vec3(0.15));\n\n    return opSmoothUnion(sphere, box, 0.4);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;\n    vec3 col = vec3(0.0);\n\n    vec2 cameraNearFar = vec2(0.01, 10.0);\n    vec3 rayOrigin = vec3(0.0, 0.0, -3.0);\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n\n    float rayDistance = 0.0;\n\n    for(int i = 0; i < 60; i++) {\n        vec3 rayPos = rayOrigin + rayDir * rayDistance;\n        float distance = scene(rayPos);\n        rayDistance += distance;\n        if(distance < 0.001 || rayDistance > cameraNearFar.y) break;\n    }\n\n    col = palette(rayDistance / cameraNearFar.y);\n    gl_FragColor = vec4(col, 1.0);\n}"
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "?section-code-language": "glsl",
        "section-code": "//structure for the transform\nstruct Transform {\n    vec3 position;\n    vec3 rotation;\n    vec3 scale;\n};\n\nTransform defaultTransform() {\n    Transform t;\n    t.position = vec3(0.0, 0.0, 0.0);\n    t.rotation = vec3(0.0, 0.0, 0.0);\n    t.scale = vec3(1.0, 1.0, 1.0);\n    return t;\n}\n\n//transforms the object in position, rotation and scale \nvec3 rot3D(vec3 pos, vec3 rot) {\n    float yaw = radians(rot.y);\n    float pitch = radians(rot.x);\n    float roll = radians(rot.z);\n\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    );\n\n    mat3 rotY = mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    );\n\n    mat3 rotZ = mat3(\n        cos(roll), -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    mat3 rotMatrix = rotZ * rotY * rotX;\n    return rotMatrix * pos;\n}\n\nvec3 applyTransform(vec3 pos, Transform transform) {\n    pos = pos - transform.position;\n    pos = rot3D(pos, transform.rotation);\n    pos = pos / transform.scale;\n    return pos;\n}\n\n//SDF's\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//SDF Operators\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette(float t) {\n    vec3 a = vec3(0.681, 0.768, 0.968);\n    vec3 b = vec3(0.245, 0.764, 0.721);\n    vec3 c = vec3(1.202, 0.362, 0.660);\n    vec3 d = vec3(0.481, 3.592, 5.705);\n    return a + b*cos(6.283185*(c*t + d));\n}\n\n//Scene\nfloat scene(vec3 worldPos) {\n    Transform sphereTransform = defaultTransform();\n    sphereTransform.position = vec3(0, 0, 0);\n    float sphere = sdSphere(applyTransform(worldPos, sphereTransform), 1.0);\n\n    Transform boxTransform = defaultTransform();\n    vec3 newPos = worldPos + vec3(0, 0, iTime * 2.5);\n    vec3 repeatedPos = fract(newPos) - 0.5;\n    boxTransform.rotation = vec3(iTime * 30.0, iTime * 30.0, iTime * 30.0);\n    float box = sdBox(applyTransform(repeatedPos, boxTransform), vec3(0.15 + sin(iTime * 2.5) * 0.05));\n\n    return opSmoothUnion(sphere, box, 0.4);\n}\n\n//Fragment\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec2 cameraNearFar = vec2(0.01, 10.0);\n\n    Transform cameraTransform = defaultTransform();\n    cameraTransform.position = vec3(0.0, 0.0, -3.0);\n    vec3 relativeRot = vec3(0.0, 0.0, iTime * 10.0);\n    cameraTransform.rotation = rot3D(normalize(vec3(uv * 1.0, 1.0)), relativeRot);\n\n    float rayDistance = 0.0;\n    int i;\n    for(i = 0; i < 60; i++) {\n        vec3 rayPos = cameraTransform.position + cameraTransform.rotation * rayDistance;\n        float distance = scene(rayPos);\n        rayDistance += distance;\n        if(distance < cameraNearFar.x || rayDistance > cameraNearFar.y) break;\n    }\n\n    col = vec3(palette(rayDistance * 0.1 + float(i)/40.0));\n    col *= vec3(max(0.75, 1.0 - float(i)/80.0));\n    col = vec3(palette(rayDistance / cameraNearFar.y));\n\n    fragColor = vec4(col, 1.0);\n}"
      }
    ]
  }
]
