{
  "type": "ShaderToy",
  "shader": "precision highp float;\r\n\r\n\/\/ variables passed from the scene manager\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\nuniform vec3 u_camPos;\r\nuniform vec3 u_camRot;\r\nuniform float u_camNear;\r\nuniform float u_camFar;\r\nuniform float u_scrollModifier;\r\n\r\n\/\/ basic structure to save data about an object\r\nstruct Transform {\r\n    vec3 position;\r\n    vec3 rotation;\r\n    vec3 scale;\r\n};\r\n\r\nTransform defaultTransform() {\r\n    Transform t;\r\n    t.position = vec3(0.0);\r\n    t.rotation = vec3(0.0);\r\n    t.scale = vec3(1.0);\r\n    return t;\r\n}\r\n\r\n\/\/ logic handling object rotation\r\nvec3 rotateX(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\r\n}\r\n\r\nvec3 rotateZ(vec3 p, float angle) {\r\n    float c = cos(angle);\r\n    float s = sin(angle);\r\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\r\n}\r\n\r\nvec3 rot3D(vec3 p, vec3 rot) {\r\n    p = rotateX(p, rot.x);\r\n    p = rotateY(p, rot.y);\r\n    p = rotateZ(p, rot.z);\r\n    return p;\r\n}\r\n\r\nvec3 applyTransform(vec3 pos, Transform t) {\r\n    pos -= t.position;\r\n    pos = rot3D(pos, t.rotation);\r\n    pos \/= t.scale;\r\n    return pos;\r\n}\r\n\r\n\/\/ SDF's for specific shapes\r\nfloat sdSphere(vec3 p, float s) {\r\n    return length(p) - s;\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\n\/\/ operators to combine 2 objects\r\nfloat opSmoothUnion(float d1, float d2, float k) {\r\n    float h = clamp(0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0);\r\n    return mix(d2, d1, h) - k*h*(1.0-h);\r\n}\r\n\r\n\/\/ color pallete\r\nvec3 palette(float t) {\r\n    vec3 a = vec3(0.681, 0.768, 0.968);\r\n    vec3 b = vec3(0.245, 0.764, 0.721);\r\n    vec3 c = vec3(1.202, 0.362, 0.660);\r\n    vec3 d = vec3(0.481, 3.592, 5.705);\r\n    return a + b*cos(6.283185*(c*t + d));\r\n}\r\n\r\n\r\n\/\/ returns the local position inside the cell (centered around 0)\r\n\/\/ and outputs the integer cell ID\r\nvec3 fractCell(vec3 worldPos, float cellSize, out vec3 cellId) {\r\n    vec3 scaledPos = worldPos \/ cellSize;\r\n    cellId = floor(scaledPos);\r\n    return fract(scaledPos) * cellSize - cellSize * 0.5;\r\n}\r\n\r\n\r\n\/\/ Helper to get a random value based on a position\r\nfloat randomValue(vec3 cellId) {\r\n    cellId = fract(cellId * 0.3183099 + 0.1);\r\n    cellId *= 17.0;\r\n    return fract(cellId.x * cellId.y * cellId.z * (cellId.x + cellId.y + cellId.z));\r\n}\r\n\r\n\/\/ create the object that is repeated across the scene\r\nfloat cubeSphere(vec3 worldPos) {\r\n    Transform boxTransform = defaultTransform();\r\n    vec3 cellId;\r\n    float cellSize = 2.0 * u_scrollModifier;\r\n\r\n    \/\/ get repeated local position and cell id\r\n    vec3 repeatedPos = fractCell(worldPos + vec3(0.0, 0.0, u_time), cellSize, cellId);\r\n\r\n    \/\/ random size per cell\r\n    float randSize = randomValue(cellId);\r\n    float size = 0.4 + randSize * 0.1;\r\n\r\n    \/\/ random rotation per cell\r\n    boxTransform.rotation = vec3(\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0,\r\n        u_time + randSize * 2.0\r\n    );\r\n\r\n    vec3 localPos = applyTransform(repeatedPos, boxTransform);\r\n    float box = sdBox(localPos, vec3(size));\r\n    float sphere = sdSphere(localPos, size);\r\n\r\n    \/\/ smooth saw tooth sine\r\n    float sine = sin(u_time * 6.283185 \/ 8.0);\r\n    float y = tanh(sine * 5.0) * 0.5 + 0.5;\r\n    \r\n    return mix(box, sphere, y);\r\n}\r\n\r\n\/\/ holds the entire scene to do raymarching on\r\nfloat scene(vec3 worldPos) {\r\n    Transform sphereTransform = defaultTransform();\r\n    float sphere = sdSphere(applyTransform(worldPos, sphereTransform), 1.0);\r\n\r\n    float cubeSphere = cubeSphere(worldPos); \r\n\r\n    return opSmoothUnion(sphere, cubeSphere, 0.4);\r\n}\r\n\r\n\/\/ Estimate gradient (normal) of the SDF at a point within the scene\r\nvec3 estimateNormal(vec3 p) {\r\n    float eps = 0.001;\r\n    float dx = scene(p + vec3(eps, 0.0, 0.0)) - scene(p - vec3(eps, 0.0, 0.0));\r\n    float dy = scene(p + vec3(0.0, eps, 0.0)) - scene(p - vec3(0.0, eps, 0.0));\r\n    float dz = scene(p + vec3(0.0, 0.0, eps)) - scene(p - vec3(0.0, 0.0, eps));\r\n    return normalize(vec3(dx, dy, dz));\r\n}\r\n\r\n\/\/ handles the shading of the scene, in a toony style\r\nvec3 shadeScene(vec3 sceneColor, vec3 hitPos, vec3 rayDir, float rayDistance) {\r\n    vec3 normal = vec3(0.0);\r\n    vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));\r\n    float lighting = 1.0;\r\n\r\n    bool hit = (rayDistance < u_camFar);\r\n    if(hit) {\r\n        normal = estimateNormal(hitPos);\r\n\r\n        \/\/ Lambertian shading\r\n        float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\r\n\r\n        int steps = 3;\r\n        diffuse = floor(diffuse * float(steps)) \/ float(steps);\r\n\r\n        \/\/ Add ambient\r\n        float ambient = 0.7;\r\n        lighting = ambient + (1.0 - ambient) * diffuse;\r\n    }\r\n\r\n    return hit ? sceneColor * lighting : sceneColor;\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) \/ u_resolution.y;\r\n    vec3 col = vec3(0.0);\r\n\r\n    Transform cameraTransform = defaultTransform();\r\n    cameraTransform.position = u_camPos;\r\n    vec3 rayDir = rot3D(normalize(vec3(uv, 1.0)), u_camRot);\r\n\r\n    \/\/ the actual raymarching\r\n    float rayDistance = 0.0;\r\n    vec3 hitPos;\r\n    int i;\r\n    for(i = 0; i < 100; i++){\r\n        hitPos = cameraTransform.position + rayDir * rayDistance;\r\n        float distance = scene(hitPos);\r\n        rayDistance += distance;\r\n        if(distance < u_camNear || rayDistance > u_camFar) break;\r\n    }\r\n\r\n    \/\/ Base color from depth, and add shading\r\n    col = palette(rayDistance \/ u_camFar * 2.5);\r\n    col = shadeScene(col, hitPos, rayDir, rayDistance);\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}"
}