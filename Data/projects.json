[
  {
    "title": "Towaria",
    "subtitle": "A voxel based tower defense.",
    "thumbnail": "Images/Projects/Towaria/towaria_preview.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "Towaria is a challenging tower defense game where letting enemies reach the end means defeat. \n\nPlace auto-firing towers to eliminate all enemies and advance through waves. Survive the final wave to move on to the next level.",
        "section-image": "Images/Projects/Towaria/towaria_preview.png"
      },
      {
        "?section-name": "contribution",
        "?section-icon": "Images/Icons/briefcase.png",
        "section-description": "I focused on core game mechanics, like tower placement and stats. \n\nI also contributed to 3D models (ground tiles, a tower, enemies) and helped polish the UI to ensure visual consistency after functionality was implemented.",
        "section-image": "Images/Projects/Towaria/towaria_preview2.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Images/Projects/Towaria/towaria_preview.png",
          "Images/Projects/Towaria/towaria_preview2.png",
          "Images/Projects/Towaria/towaria_3d_models.png"
        ]
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "section-code": "\/\/\/ This script manages the movement of every enemy.  \r\n\/\/\/ Add an enemy to the list if you want it to be controlled by this script,  \r\n\/\/\/ remove it when you want it to stop being controlled by this script.\r\n\r\nusing UnityEngine;\r\nusing Unity.Jobs;\r\nusing Unity.Burst;\r\nusing Unity.Collections;\r\nusing UnityEngine.Jobs;\r\nusing System.Collections.Generic;\r\n\r\npublic class EnemyMovementSystem : MonoBehaviour\r\n{\r\n    \/\/ Enemies hold all enemies. enemiesToUpdate is a list of all enemies used in the current job,\r\n    \/\/ to avoid shifting list issues.\r\n    private readonly List<EnemyBase> enemies = new();\r\n    private List<EnemyBase> enemiesToUpdate = new();\r\n\r\n    \/\/ Store some values to avoid having to call pathCreator more than needed.\r\n    public Vector3 PathStart { get; private set; }\r\n    private int pathReachedEndIndex;\r\n\r\n    \/\/ Data to pass on to job. Native arrays are required when using jobs (multithreading).\r\n    private TransformAccessArray enemyTransforms;\r\n    private NativeArray<Vector3> pathNodes;\r\n    private NativeArray<float> speeds;\r\n    private NativeArray<Vector3> offsets;\r\n    private NativeArray<int> targetNodeIndices;\r\n    private CreateAIPath pathCreator;\r\n    \/\/ Stores a reference to the job itself.\r\n    private JobHandle jobHandle;\r\n    private bool jobAlreadyCompleted = false;\r\n\r\n    \/\/ Allow enemy to add and remove itself to the movement job.\r\n    public void AddEnemy(EnemyBase enemy) => enemies.Add(enemy);\r\n    public void RemoveEnemy(EnemyBase enemy) => enemies.Remove(enemy);\r\n\r\n    private void Start()\r\n    {\r\n        pathCreator = FindFirstObjectByType<CreateAIPath>();\r\n        pathCreator.RegeneratedPaths += InitializePathNodes;\r\n    }\r\n\r\n    public void InitializePathNodes()\r\n    {\r\n        PathStart = pathCreator.Path[0];\r\n        pathReachedEndIndex = pathCreator.Path.Count;\r\n\r\n        \/\/ Dispose the pathNodes if it has already been created.\r\n        if (pathNodes.IsCreated)\r\n        {\r\n            jobHandle.Complete();\r\n            pathNodes.Dispose();\r\n        }\r\n\r\n        pathNodes = new NativeArray<Vector3>(pathCreator.Path.ToArray(), Allocator.Persistent);\r\n    }\r\n\r\n    \/\/ Called after update functions have been called.\r\n    private void Update()\r\n    {\r\n        \/\/ If the job is completed, complete the job,\r\n        \/\/ write some data to the AI and create a new job.\r\n        if (jobHandle.IsCompleted)\r\n        {\r\n            \/\/ Force job to complete.\r\n            jobHandle.Complete();\r\n\r\n            \/\/ If this is the first time this job has been marked as completed, run this code,\r\n            \/\/ to avoid unnecessary repeated writing to the enemies.\r\n            if (!jobAlreadyCompleted)\r\n            {\r\n                \/\/ Mark this job as already completed once.\r\n                jobAlreadyCompleted = true;\r\n\r\n                \/\/ Check if the enemy count is greater than 0,\r\n                \/\/ and if all the arrays are created (by checking the main one).\r\n                if (enemiesToUpdate.Count > 0 && enemyTransforms.isCreated)\r\n                {\r\n                    \/\/ Update target indices of the enemies using information from the job.\r\n                    for (int i = 0; i < enemiesToUpdate.Count; i++)\r\n                    {\r\n                        enemiesToUpdate[i].TargetNodeIndex = targetNodeIndices[i];\r\n                        if (enemiesToUpdate[i].TargetNodeIndex >= pathReachedEndIndex)\r\n                        {\r\n                            enemiesToUpdate[i].HasReachedEnd();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                \/\/ Dispose of the data that changes between jobs to free up space.\r\n                DisposeMost();\r\n            }\r\n\r\n            \/\/ Create and run a new job only if there are enemies present.\r\n            if (enemies.Count > 0)\r\n            {\r\n                jobAlreadyCompleted = false;\r\n                jobHandle = CreateJobData().Schedule(enemyTransforms);\r\n            }\r\n        }\r\n    }\r\n\r\n    public EnemyMoveJob CreateJobData()\r\n    {\r\n        enemiesToUpdate = new(enemies);\r\n\r\n        \/\/ Create new native arrays with the length of enemies.\r\n        enemyTransforms = new TransformAccessArray(enemiesToUpdate.Count);\r\n        speeds = new NativeArray<float>(enemiesToUpdate.Count, Allocator.Persistent);\r\n        offsets = new NativeArray<Vector3>(enemiesToUpdate.Count, Allocator.Persistent);\r\n        targetNodeIndices = new NativeArray<int>(enemiesToUpdate.Count, Allocator.Persistent);\r\n\r\n        \/\/ Fill all the native arrays in a single for loop,\r\n        \/\/ skip hasReachedEnd because we fill it with false for every enemy.\r\n        for (int i = 0; i < enemiesToUpdate.Count; i++)\r\n        {\r\n            EnemyBase enemy = enemiesToUpdate[i];\r\n            enemyTransforms.Add(enemy.transform);\r\n            speeds[i] = enemy.Speed;\r\n            offsets[i] = enemy.RandomOffset;\r\n            targetNodeIndices[i] = enemy.TargetNodeIndex;\r\n        }\r\n\r\n        \/\/ Return the data as an EnemyMoveJob struct,\r\n        \/\/ this needs to be filled in fully, otherwise the job gets angry.\r\n        return new()\r\n        {\r\n            DeltaTime = Time.deltaTime,\r\n            PathNodes = pathNodes,\r\n            Speeds = speeds,\r\n            Offsets = offsets,\r\n            TargetNodeIndices = targetNodeIndices,\r\n        };\r\n    }\r\n\r\n    \/\/ Dispose of everything when this object is destroyed,\r\n    \/\/ otherwise unnecessary memory is used.\r\n    private void OnDestroy()\r\n    {\r\n        jobHandle.Complete();\r\n        DisposeMost();\r\n        if (pathNodes.IsCreated) pathNodes.Dispose();\r\n    }\r\n\r\n    \/\/\/ <summary>\r\n    \/\/\/ Dispose of data that changes between jobs to free up space.\r\n    \/\/\/ Garbage collection doesn't happen automatically on native arrays;\r\n    \/\/\/ you have to dispose of them yourself, otherwise you will get a memory leak.\r\n    \/\/\/ <\/summary>\r\n    private void DisposeMost()\r\n    {\r\n        if (enemyTransforms.isCreated) enemyTransforms.Dispose();\r\n        if (speeds.IsCreated) speeds.Dispose();\r\n        if (offsets.IsCreated) offsets.Dispose();\r\n        if (targetNodeIndices.IsCreated) targetNodeIndices.Dispose();\r\n    }\r\n}\r\n\r\n\/\/ Burst compiler, very efficient, but limited Unity functions.\r\n\/\/ Also garbage collection needs to be done by yourself.\r\n[BurstCompile]\r\npublic struct EnemyMoveJob : IJobParallelForTransform\r\n{\r\n    \/\/ Data as a struct. When you don't want a job to modify data,\r\n    \/\/ make sure it's set to readonly.\r\n    [ReadOnly] public float DeltaTime;\r\n    [ReadOnly] public NativeArray<Vector3> PathNodes;\r\n    [ReadOnly] public NativeArray<float> Speeds;\r\n    [ReadOnly] public NativeArray<Vector3> Offsets;\r\n    public NativeArray<int> TargetNodeIndices;\r\n\r\n    \/\/ Move every object with its own data.\r\n    public void Execute(int index, TransformAccess transform)\r\n    {\r\n        \/\/ If target index is too big, just don't.\r\n        if (TargetNodeIndices[index] >= PathNodes.Length)\r\n        {\r\n            Debug.LogWarning($\"Target index of enemy {index} was out of range of the path.\");\r\n            return;\r\n        }\r\n\r\n        \/\/ Get the information for this specific index.\r\n        float speed = Speeds[index];\r\n        Vector3 offset = Offsets[index];\r\n        int targetNodeIndex = TargetNodeIndices[index];\r\n\r\n        \/\/ If target index is 0 (at the start of the path),\r\n        \/\/ position at the beginning and increment the target position.\r\n        if (targetNodeIndex == 0)\r\n        {\r\n            transform.SetPositionAndRotation(PathNodes[targetNodeIndex], Quaternion.identity);\r\n            targetNodeIndex++;\r\n            TargetNodeIndices[index] = targetNodeIndex;\r\n        }\r\n\r\n        \/\/ Save the current and target position.\r\n        Vector3 currentPosition = transform.position;\r\n        Vector3 targetPosition = PathNodes[targetNodeIndex] + offset;\r\n\r\n        \/\/ Update the transform based on the distance you need to go.\r\n        transform.position = Vector3.MoveTowards(currentPosition, targetPosition, speed * DeltaTime);\r\n\r\n        \/\/ Check if needs to be rotated, if so rotate.\r\n        Vector3 direction = (targetPosition - currentPosition).normalized;\r\n        \/\/ If there's a valid direction, rotate smoothly.\r\n        if (direction.sqrMagnitude > 0.0001f) \/\/ Avoid division by zero and insignificant values.\r\n        {\r\n            \/\/ Get the target rotation based on the direction.\r\n            Quaternion targetRotation = Quaternion.LookRotation(direction);\r\n            \/\/ Smoothly rotate from current rotation to target rotation.\r\n            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, 5 * DeltaTime);\r\n        }\r\n\r\n        \/\/ Check if enemy has reached the target node with a tolerance.\r\n        if (Vector3.Distance(transform.position, targetPosition) <= 0.01f) TargetNodeIndices[index]++;\r\n    }\r\n}\r\n"
      }
    ],
    "links": [
      {
        "name": "Github",
        "icon": "Images/Socials/Github.png",
        "link": "https://github.com/Egg321123/J2P1_microgame/releases/tag/prototype-03"
      },
      {
        "name": "Direct",
        "icon": "Images/Icons/download.png",
        "link": "https://github.com/Egg321123/J2P1_microgame/releases/download/prototype-03/Towaria.apk"
      }
    ]
  },
  {
    "title": "The Filth",
    "subtitle": "90's desktop bullet hell.",
    "thumbnail": "Images/Projects/TheFilth/TheFilth_preview.png",
    "data-filter": "Unity",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "The Filth is a space shooter-like game made during a gamejam with the theme: \"Making free space\", where you have to shoot at files to destroy them, and survive their attacks. \n\nAs the player you can shoot projectiles to destroy enemies, and also have access to a special attack that hurts multiple enemies.",
        "section-image": "Images/Projects/TheFilth/TheFilth_preview.png"
      },
      {
        "?section-name": "contribution",
        "?section-icon": "Images/Icons/briefcase.png",
        "section-description": "In this project my role was SCRUM master and lead developer. \n\nI focused on integrating game systems that the other group members made, but also made my own systems like the spawning grid. I also made the UI of the game.",
        "section-image": "Images/Projects/TheFilth/TheFilth_preview2.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Images/Projects/TheFilth/TheFilth_preview.png",
          "Images/Projects/TheFilth/TheFilth_sprites.png",
          "Images/Projects/TheFilth/TheFilth_preview2.png"
        ]
      },
      {
        "?section-name": "code",
        "?section-icon": "Images/Icons/coding.png",
        "section-code": "\/\/\/ Controls the \"eye\" in the center of the screen. \r\n\/\/\/ it either looks at the player or a random points on screen, \r\n\/\/\/ switching targets at random intervals.\r\n\r\nusing System.Collections;\r\nusing UnityEngine;\r\n\r\npublic class TheFilthLook : MonoBehaviour\r\n{\r\n    [SerializeField] \r\n    private GameObject eye = null;\r\n    [SerializeField]\r\n    private float minDistanceFromPlayer = 0.5f;\r\n    [SerializeField]\r\n    private Vector2 TargetSwitchDelay = Vector2.zero;\r\n    [SerializeField]\r\n    private float lookSpeed = 5f;\r\n\r\n    private Transform playerT = null;\r\n    private float minX, maxX, minY, maxY = 0;\r\n    private bool isFollowingPlayer = false;\r\n    private Vector2 target = Vector2.zero;\r\n\r\n    void Start()\r\n    {\r\n        playerT = GameObject.FindGameObjectWithTag(\"Player\").transform;\r\n\r\n        \/\/ensures the eye chooses a point that's actually on the screen.\r\n        Vector2 bottomLeft = Camera.main.ViewportToWorldPoint(Vector2.zero);\r\n        Vector2 topRight = Camera.main.ViewportToWorldPoint(Vector2.one);\r\n\r\n        minX = bottomLeft.x;\r\n        minY = bottomLeft.y;\r\n        maxX = topRight.x;\r\n        maxY = topRight.y;\r\n\r\n        target = transform.position;\r\n        StartCoroutine(ChooseTarget());\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        \/\/\/ calculates the point where the eye needs to move to, \r\n        \/\/\/ limited to a radius from the root object.\r\n        Vector2 dir = target - (Vector2)transform.position;\r\n        float distance = dir.magnitude;\r\n\r\n        if (distance > 0f)\r\n        {\r\n            dir \/= distance;\r\n        }\r\n\r\n        dir *= minDistanceFromPlayer;\r\n\r\n        if (isFollowingPlayer && distance > minDistanceFromPlayer)\r\n        {\r\n            target = playerT.position;\r\n        }\r\n\r\n        \/\/ actually move the eye, smoothly\r\n        eye.transform.position = Vector2.Lerp\r\n            (\r\n                eye.transform.position,\r\n                (Vector2)transform.position + dir,\r\n                Time.deltaTime * lookSpeed\r\n            );\r\n    }\r\n\r\n    IEnumerator ChooseTarget()\r\n    {\r\n        \/\/ delay to avoid it moving at the start.\r\n        yield return new WaitForSecondsRealtime(10f);\r\n\r\n        \/\/ not save, but okay for a gamejam game.\r\n        while (true)\r\n        {\r\n            float minDelay = TargetSwitchDelay.x;\r\n            float maxDelay = TargetSwitchDelay.y;\r\n\r\n            if (isFollowingPlayer)\r\n            {\r\n                minDelay += 5;\r\n                maxDelay += 5;\r\n            }\r\n\r\n            float randomDelay = Random.Range(minDelay, maxDelay);\r\n            yield return new WaitForSecondsRealtime(randomDelay);\r\n\r\n            isFollowingPlayer = Random.value < 0.5f;\r\n\r\n            if (!isFollowingPlayer)\r\n            {\r\n                target = ChooseRandomLookTarget();\r\n            }\r\n        }\r\n    }\r\n\r\n    Vector2 ChooseRandomLookTarget()\r\n    {\r\n        Vector2 target = Vector2.zero;\r\n\r\n        target.x = Random.Range(minX, maxX);\r\n        target.y = Random.Range(minY, maxY);\r\n\r\n        return target;\r\n    }\r\n}\r\n"
      }
    ],
    "links": [
      {
        "name": "Github",
        "icon": "Images/Socials/Github.png",
        "link": "https://github.com/Lyritha/TheFilth/releases/tag/GameJam-Release"
      },
      {
        "name": "UnityPlay",
        "icon": "Images/Software/unity.png",
        "link": "https://play.unity.com/en/games/b90b0494-ef42-4095-bdf8-ac9bbe0ff9be/the-filth"
      }
    ]
  },
  {
    "title": "Tiny house",
    "subtitle": "A small cozy house",
    "thumbnail": "Images/Projects/TinyHouse/Hous_Front.png",
    "data-filter": "Blender",
    "sections": [
      {
        "?section-name": "about",
        "?section-icon": "Images/Icons/user.png",
        "section-description": "A to-scale tiny house created in Blender. Everything in the scene was modeled by me, except for the grass. \n\nThis 3D model was made for a school assignment for my software development degree.",
        "section-image": "Images/Projects/TinyHouse/Hous_Top.png"
      },
      {
        "?section-name": "gallery",
        "?section-icon": "Images/Icons/education.png",
        "section-images": [
          "Images/Projects/TinyHouse/Hous_Front.png",
          "Images/Projects/TinyHouse/Hous_Top.png",
          "Images/Projects/TinyHouse/Hous_Back.png",
          "Images/Projects/TinyHouse/Hous_BedRoom.png",
          "Images/Projects/TinyHouse/Hous_Bathroom.png"
        ]
      }
    ]
  }
]
